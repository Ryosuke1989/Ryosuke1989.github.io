<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++</title>
    <link href="/2024/09/15/C/"/>
    <url>/2024/09/15/C/</url>
    
    <content type="html"><![CDATA[<h1 id="C-学习"><a href="#C-学习" class="headerlink" title="C++学习"></a>C++学习</h1><h2 id="一、C语言进阶"><a href="#一、C语言进阶" class="headerlink" title="一、C语言进阶"></a>一、C语言进阶</h2><h3 id="内存四区"><a href="#内存四区" class="headerlink" title="内存四区"></a>内存四区</h3><ul><li><p>代码区</p><p>存储内容：程序的二进制代码。</p><p>特性：存放CPU执行的代码，数据不可修改，只能执行。</p></li><li><p>全局区</p><p>存储内容：静态变量、全局变量和常量（包括字符串常量）。</p><p>特性：在程序编译阶段分配内存并初始化，内存在程序的整个运行期间都存在。</p></li><li><p>栈区 </p><p>存储内容：函数的参数值、局部变量等。</p><p>特性：由系统自动分配释放，遵循先进后出的原则。栈的大小可以在编译器中设置，如Visual Studio中默认为1MB。</p></li><li><p>堆区 </p><p>存储内容：动态分配的内存，如使用<code>new</code>或<code>malloc</code>分配的内存。</p><p>特性：需要程序员手动申请和释放，若不释放，程序结束后由操作系统回收。生命周期贯穿程序的运行期间。</p></li></ul><h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><ul><li><p>内存对齐的目的：避免二次访问，提高运行效率</p></li><li><p>对齐模数：结构体中最大数据类型的大小</p></li><li><p>内存对齐规则：</p><ul><li>第一个属性开始，从偏移量未0的位置开始存储</li><li>第二个属性，放在该数据类型大小和对齐模数相比较小值的整数倍上</li><li>整体计算完毕后，要进行二次对齐，结构体大小必须是该结构体中的最大的数据类型与对齐模数相比，较小值的整数倍，不足要补齐</li></ul></li><li><p>结构体嵌套结构体的对齐规则：</p><ul><li>对齐模数：外部结构体中数据类型（不包括内部结构体）与内部结构体中数据类型的最大值</li></ul></li></ul><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><ul><li><p>文件流<code>&lt;fstream&gt;</code></p></li><li><p>文件类型：文本文件：以ASCII码形式存储</p><p>​   二进制文件：以二进制形式存储</p></li><li><p>文件操作：读文件：ofstream</p><p>​   写文件：ifstream</p><pre><code class="hljs">      读写文件：fstream</code></pre></li><li><p>文件打开方式：</p></li></ul><table><thead><tr><th>打开方式</th><th>对应功能</th></tr></thead><tbody><tr><td>ios::in</td><td>以读模式打开文件</td></tr><tr><td>ios::out</td><td>以写模式打开文件</td></tr><tr><td>ios::ate</td><td>将文件指针移到末尾（可以更改写入位置）</td></tr><tr><td>ios::app</td><td>在末尾以追加方式写文件（只可以在末尾写入）</td></tr><tr><td>ios::turnc</td><td>如果文件已经存在，先删除，再创建</td></tr><tr><td>ios::binary</td><td>以二进制方式打开文件</td></tr></tbody></table><p>可以使用 <code>|</code> 运算符互相组合来实现相应功能</p><ul><li><p>写文件操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span>  <span class="hljs-comment">//包含头文件</span></span><br>ofstream ofs;        <span class="hljs-comment">//创建写对象</span><br>ofs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;文件路径&quot;</span>，打开方式);     <span class="hljs-comment">//打开文件</span><br>ofs&lt;&lt;<span class="hljs-string">&quot;所写入的数据&quot;</span>; <span class="hljs-comment">//写数据</span><br>ofs.<span class="hljs-built_in">close</span>();  <span class="hljs-comment">//关闭文件</span><br></code></pre></td></tr></table></figure></li><li><p>写文件操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span> <span class="hljs-comment">//包含头文件</span></span><br>ifstream ifs；<span class="hljs-comment">//创建读对象</span><br>ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;文件路径&quot;</span>，打开方式)；  <span class="hljs-comment">//打开文件</span><br>四种读取方式 <span class="hljs-comment">//读数据</span><br>ifs.<span class="hljs-built_in">close</span>();     <span class="hljs-comment">//关闭文件</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="二、C-新增特性"><a href="#二、C-新增特性" class="headerlink" title="二、C++新增特性"></a>二、C++新增特性</h2><ul><li><p>I&#x2F;O流（iostream）：<code>cin&gt;&gt;</code>    <code>cout&lt;&lt;</code></p><p>​                                     cin和cout都是对象，并不是类似于c语言的scanf和printf等库函数</p><p>​     I&#x2F;O流不能被拷贝，只能进行引用传递，不能使用值传递</p></li><li><p>名称空间：允许不同名称空间相同标识符的存在，增加名称的复用</p><ul><li><p><strong>定义方法</strong>：<code>namespace 空间名 &#123;   &#125;</code><br>1.名称空间可以嵌套在另一个名称空间之中，但是不可以放在代码块中（如函数）<br>2.可以随时补充命名空间中的内容</p></li><li><p><strong>限定方法</strong>：通过作用域解析运算符<code>::</code>来限定标识符</p></li><li><p><strong>using声明</strong>：</p><p>1.使用<code>using 名称空间::标识符；</code>可将名称空间中的特定标识符引入当前作用域，该名称空间中的标识符会覆盖全局名称空间中的同名标识符</p><p>2.如果想使用全局名称空间中的同名标识符，可以使用<code>::标识符</code>来达到（如果直接在全局空间使用，则全局空间中的特定标识符名称会被函数内的标识符覆盖）</p><p>3.如果某个命名空间中的标识符已经在函数中使用了using声明，则不能在函数中再声明另一个名称空间的同名标识符</p><p>4.如果某个名称已经在作用域中定义了，则不能通过using声明引入另一名称空间的同名名称</p></li><li><p><strong>using编译指令</strong>：</p><p>1.使用<code>using namespace 空间名；</code>可以使该命名空间中的所有标识符覆盖当前区域中的标识符</p><p>2.在函数中使用using编译指令时，函数中的局部标识符会覆盖掉名称空间中的同名标识符，且不会报错，除非使用<code>名称空间::标识符</code>进行调用，因此需要尽量避免使用using编译指令</p></li></ul></li><li><p>布尔类型：<code>ture</code> or <code>false</code></p></li></ul><h2 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h2><ul><li>本质：指针常量</li><li>定义时必须初始化</li><li>初始化时只能够是左值</li><li>一旦初始化，值不可以更改</li><li>数组不可以引用</li></ul><table><thead><tr><th align="center">指针</th><th align="center">引用</th></tr></thead><tbody><tr><td align="center">允许空指针</td><td align="center">不允许空引用</td></tr><tr><td align="center">初始化后依旧可以修改取值</td><td align="center">初始化后不可以更改取值</td></tr><tr><td align="center">任何时间初始化</td><td align="center">只能在定义时初始化</td></tr><tr><td align="center">操纵多重指针</td><td align="center">形式上直接操纵变量</td></tr><tr><td align="center">多层嵌套、遍历数组、指针数组</td><td align="center">右值引用</td></tr></tbody></table><h2 id="四、函数高级"><a href="#四、函数高级" class="headerlink" title="四、函数高级"></a>四、函数高级</h2><h3 id="1、形参默认值"><a href="#1、形参默认值" class="headerlink" title="1、形参默认值"></a>1、形参默认值</h3><ul><li>函数定义时可以在变量名后赋初始值</li><li>如果实参传入值和形参初始值不同，以传入值为标准</li><li>如果某个变量有初始值，其后的变量都要有初始值</li><li>如果在函数声明中赋了初始值，那么在定义中就不能再赋初始值</li></ul><h3 id="2、占位参数"><a href="#2、占位参数" class="headerlink" title="2、占位参数"></a>2、占位参数</h3><ul><li>函数定义时可以只写数据类型，不写变量</li><li>占位参数存在时，实参必须有相应的传值，否则无法调用函数，可以作为函数的开关来使用</li><li>占位参数也可以赋初始值，但是这样没什么用</li><li>在运算符重载中，可以区分前置或后置自增&#x2F;自减运算符</li></ul><h3 id="3、函数重载"><a href="#3、函数重载" class="headerlink" title="3、函数重载"></a>3、函数重载</h3><ul><li>提高函数的复用性</li><li>函数重载的条件<ol><li>在同一个作用域下    </li><li>函数名称相同</li><li>函数参数类型不同、个数不同或者顺序不同</li></ol></li><li>函数的返回值并不可以作为函数重载的条件</li><li>引用重载：<code>&amp;数据类型</code>和<code>const &amp;数据类型</code>可以被看作函数重载，因为<code>const &amp;数据类型</code>作为常量被存储在内存全局区，而<code>&amp;数据类型</code>存储在栈区</li><li>重载函数参数含有默认值时，容易出现二义性，应尽量避免</li></ul><h2 id="五、类和对象"><a href="#五、类和对象" class="headerlink" title="五、类和对象"></a>五、类和对象</h2><p>C++在创建类时至少会添加四个函数：</p><p>1.构造函数</p><p>2.析构函数</p><p>3.拷贝构造函数</p><p>4.operator&#x3D;运算符重载函数</p><h3 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h3><ul><li><p>类的封装：将属性和行为作为一个整体，加以权限控制，构成一个类<br>属性和行为统称为成员<br>属性又称为成员属性或者成员变量<br>行为又称为乘员函数或者成员方法</p></li><li><p>类的定义：<code>class 类名&#123;  访问权限： 属性 行为 &#125;；</code></p></li><li><p>对象的实例化：<code>类名 对象名;</code></p></li><li><p>类的调用：<code>对象名.属性/行为；</code></p></li><li><p>类的访问权限：</p><table><thead><tr><th align="center">权限名</th><th align="center">类内访问成员</th><th align="center">类外访问成员</th><th align="center">继承</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">可以</td><td align="center">可以</td><td align="center"></td></tr><tr><td align="center">protected</td><td align="center">可以</td><td align="center">不可以</td><td align="center">子类可以访问父类保护数据</td></tr><tr><td align="center">private</td><td align="center">可以</td><td align="center">不可以</td><td align="center">子类不可以访问父类私有数据</td></tr></tbody></table></li><li><p>类和结构体之间的区别：</p><table><thead><tr><th align="center">结构体</th><th align="center">类</th></tr></thead><tbody><tr><td align="center">栈存储</td><td align="center">堆存储</td></tr><tr><td align="center">默认public权限</td><td align="center">默认private权限</td></tr></tbody></table></li><li><p>类应用：最好在新创建的源文件和头文件中写类</p><p>注意：头文件开头要避免重复编译 可以使用<code>#pragma</code>（非C++标准），或是<code>#ifndef</code> <code>#define</code> <code>#endif</code>来完成，不保留函数实现；源文件开头需要包含头文件，只保留函数实现，且标识符需要用域解析符修饰</p></li></ul><h3 id="2-构造函数、析构函数和拷贝构造函数"><a href="#2-构造函数、析构函数和拷贝构造函数" class="headerlink" title="2.构造函数、析构函数和拷贝构造函数"></a>2.构造函数、析构函数和拷贝构造函数</h3><ul><li><p>默认情况下，C++编译器至少给一个类添加3个函数：</p><ul><li><p>默认构造函数  (无参 函数体为空)</p><p>调用：<code>类名（）&#123;&#125;</code></p><p>可以有参数，可以重载</p><p>创建对象时自动调用一次</p></li><li><p>默认析构函数  (无参 函数体为空)</p><p>调用：<code>~类名 （）&#123;&#125;</code></p><p>不可以有参数，不可重载</p><p>对象销毁前自动调用，且只会调用一次</p></li><li><p>默认拷贝构造函数无参  (对属性进行值拷贝)<br>调用：<code>类名 (const 类名 &amp;被拷贝的对象名)</code></p><p>用于对象的初始化、函数传参和返回值、创建对象数组</p><p>不要使用拷贝构造函数来初始化一个匿名对象，因为编译器会认为是在实例化一个对象</p><p>使用引用可以避免对象被拷贝构造</p><table><thead><tr><th align="center">浅拷贝</th><th align="center">深拷贝</th></tr></thead><tbody><tr><td align="center">纯粹的值复制，指针只复制值</td><td align="center">完全复制，包括指针指向的内容</td></tr><tr><td align="center">一个对象修改影响另一个</td><td align="center">一个对象修改不影响另外一个</td></tr><tr><td align="center">&#x3D;&#x3D;编译器默认拷贝构造函数&#x3D;&#x3D;</td><td align="center">&#x3D;&#x3D;需要自定义拷贝构造函数&#x3D;&#x3D;</td></tr><tr><td align="center">编译器自动申请空间</td><td align="center">需要自行申请一片空间</td></tr></tbody></table></li></ul></li><li><p>调用规则:</p><ul><li>如果用户自定义一个有参构造函数,编译器不再提供默认无参构造,但是会提供默认拷贝构造</li><li>如果用户定义拷贝构造函数,编译器不再提供其他构造函数</li></ul></li><li><p>初始化成员列表：<code>类名（int a，int b）：属性1（a），属性2（b）&#123;&#125;</code></p><ul><li>可以直接在属性后的括号中写入初值，也可以通过在函数中使用<code>类名（a，b）</code>来初始化</li></ul></li><li><p>类对象作为类成员</p><ul><li>当一个对象包含另一个对象作为其成员时，成员对象必须在包含它的对象构造之前先构造。</li><li>与构造顺序相反，成员对象必须在包含它的对象析构之后再析构。</li><li>原因：包含对象在构造和析构的时候可能需要使用成员变量，因此必须保证在包含对象的生命周期内，成员对象一直是存在的</li></ul></li><li><p>静态成员:<strong>静态成员属于类本身,与实例无关</strong></p><ul><li><p>静态成员变量：</p><ul><li><p>特点：1.在编译阶段分配内存</p><p>​            2.类内声明,类外初始化(在类外部通过<code>变量类型 类名::变量名=初值</code>进行初始化)</p><p>​            3.所有对象共享一份数据</p></li><li><p>访问方法:1.通过实例化一个对象进行访问</p><p>​                 2.通过<code>类名::变量名</code>进行直接访问</p></li><li><p>私有权限无法访问</p></li></ul></li><li><p>静态成员函数:</p><ul><li><p>特点:1.所有对象共享一个函数</p><p>​         2.静态成员函数<strong>只能访问静态成员变量</strong></p></li><li><p>&#x3D;&#x3D;访问方法&#x3D;&#x3D;:1.通过实例化一个对象进行访问</p><p>​                 2.通过<code>类名::函数名</code>进行直接访问</p></li><li><p>私有权限无法访问</p></li></ul></li></ul></li></ul><h3 id="3-对象特性"><a href="#3-对象特性" class="headerlink" title="3.对象特性"></a>3.对象特性</h3><ul><li><p>空对象的大小为<strong>1个字节</strong>，有自己独一无二的内存地址</p></li><li><p>对象的成员变量和成员函数分开存储：</p><table><thead><tr><th align="center">变量和函数</th><th align="center">存储位置</th></tr></thead><tbody><tr><td align="center">非静态成员变量</td><td align="center">属于类的对象</td></tr><tr><td align="center">静态成员变量</td><td align="center">不属于类的对象（只有一份）</td></tr><tr><td align="center">非静态成员函数</td><td align="center">不属于类的对象（只有一份）</td></tr><tr><td align="center">静态成员函数</td><td align="center">不属于类的对象（只有一份）</td></tr></tbody></table></li></ul><h3 id="4-this-指针"><a href="#4-this-指针" class="headerlink" title="4.this 指针"></a>4.this 指针</h3><ul><li>this指针的本质是<strong>指针常量</strong>，在类的非静态成员函数中用来指向调用该函数的对象，不可以更改指向</li><li>this指针隐式存在于类的非静态成员函数中,无须显式定义</li><li>类的静态成员函数没有this指针，因为静态成员函数属于类本身</li><li>应用：<ul><li>当类的成员变量与函数的参数或局部变量同名时，可以使用this指针指向这个成员<code>this -&gt; 成员变量</code>来表示该变量是成员变量 </li><li>实现链式操作:当一个函数想返回这个对象时，可使用<code>*this</code>作为返回值（注意，函数的返回值应为<code>类名&amp;</code>形式，表示对象的引用，如果使用值返回，会自动调用拷贝构造函数，返回的对象不是原来的对象，而是一个新的对象）</li></ul></li></ul><h3 id="5-常函数和常对象"><a href="#5-常函数和常对象" class="headerlink" title="5.常函数和常对象"></a>5.常函数和常对象</h3><ul><li>在函数后加上const，如：<code>返回值类型 函数名（参数）const</code>即可声明<strong>常函数</strong>，其中的this指针既不可以修改指向，也不可以调用this指针修改对象中的内容</li><li>如果想在常函数中修改对象中的内容，在this指针调用语句前加上<code>mutable</code>，便可以修改取值</li><li>在对象名前加上const，即可声明<strong>常对象</strong>，<code>const 类名 对象名；</code></li><li>常对象只能调用常函数</li></ul><h3 id="6-友元"><a href="#6-友元" class="headerlink" title="6.友元"></a>6.友元</h3><ul><li>友元允许其他类或者全局函数访问类中的私有或者保护成员</li><li>全局函数做友元：通过<code>friend 函数声明；</code>的形式使得全局函数做友元</li><li>类做友元：通过<code>friend 类声明；</code>的形式使得类做友元</li><li>成员函数做友元：通过<code>friend 类名：：成员函数声明；</code>的形式使得成员函数做友元</li><li>友元关系不对称，不传递，只有独立声明一种选择</li></ul><h3 id="7-运算符重载"><a href="#7-运算符重载" class="headerlink" title="7.运算符重载"></a>7.运算符重载</h3><ul><li><p>概念：对已经存在的运算符进行另外一种定义，赋予另外一种功能，以便于适应不同的数据类型</p></li><li><p>定义方式：定义一个名为<code>operate 重载运算符</code>的类成员函数或是全局函数</p></li><li><p>注意事项：内置数据类型不能够发生重载</p><p>​                   不要滥用运算符重载</p><p>​           如果重载运算符函数定义在类中，则不需要将自身作为参数传入，如果定义在全局区，则需要将自              身作为参数传入</p></li><li><p>加法运算符重载：用于两个类的直接相加</p></li><li><p>左移运算符重载 ：用于直接输出类的成员<br>定义格式 ：</p></li><li><pre><code class="c++">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; cout, const 类名&amp; obj) //I/O流只允许引用传递&#123;    // 实现你的输出操作    return cout; //便于实现链式调用&#125; //通常将类的成员设为private 通过友元函数使位于全局区的重载运算符调用内部成员<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br>- 递增运算符重载：<br><br>  前置递增重载：==可以链式调用==<br><br>  ```c++<br>     <span class="hljs-comment">// 重载前置递增运算符</span><br>      类名&amp; <span class="hljs-keyword">operator</span>++()   <span class="hljs-comment">//返回引用是为了对一个对象持续进行操作，不然会发生拷贝构造</span><br>      &#123;<br>          ++value;<br>          <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>      &#125;<br></code></pre></td></tr></table></figure>后置递增重载：==不可以链式调用==<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 重载后置递增运算符 </span><br>类名 <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)  <span class="hljs-comment">//返回值是为了返回一个自增前的值，因为自增前后的值并不一样</span><br>&#123;<br>    Counter temp = *<span class="hljs-keyword">this</span>;<br>    ++value;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>赋值运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>* data;<br><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> value) <span class="hljs-comment">//使用构造函数在堆区申请一片新的内存空间</span><br>    &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(value);<br>    &#125;<br><br>    ~<span class="hljs-built_in">MyClass</span>() <span class="hljs-comment">//使用析构函数手动释放在堆区申请的空间</span><br>    &#123;<br>        <span class="hljs-keyword">delete</span> data;<br>    &#125;<br>    <br> <span class="hljs-comment">//因为要实现链式调用，函数的返回值必须为引用</span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass &amp;other) <br>    &#123;<br>         <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) <br>         &#123;<br>            <span class="hljs-keyword">delete</span>[] data;<span class="hljs-comment">// 释放当前对象的资源</span><br>            data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.data);  <span class="hljs-comment">// 深拷贝数据成员</span><br>         &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">//返回对象自身，便于链式调用</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>关系运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> MyClass&amp; other) <span class="hljs-type">const</span> <br>&#123;<br>   <span class="hljs-keyword">if</span>(关系判断条件)<br>   &#123;<br>   <span class="hljs-keyword">return</span> ture;<br>   &#125;<span class="hljs-keyword">else</span><br>   &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>函数调用运算符重载</p><p>无固定写法 使对象像函数一样被调用，实现想要的功能，被称为仿函数，例：&#x3D;&#x3D;&#x3D;&#x3D;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function"></span>&#123;<br>       <span class="hljs-keyword">return</span> value + x;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="8-继承"><a href="#8-继承" class="headerlink" title="8.继承"></a>8.继承</h3><ul><li><p>继承的用处：减少重复代码</p></li><li><p>继承的原理：再子类构造前调用父类的构造函数构造一个父类，然后再进行子类的构造，事实上就是通过简单的代码隐去了调用父类构造函数的代码，避免了类之间出现大量的重复代码</p></li><li><p>继承的使用方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> 子类（派生类） ：继承方式 父类（基类）<br></code></pre></td></tr></table></figure></li><li><p>继承的方式：公共继承、保护继承、私有继承</p><ul><li><p>公共继承：父类中的公共权限成员到子类中&#x3D;&#x3D;依旧是公共权限&#x3D;&#x3D;</p><p>​                   父类中的保护权限成员到子类中&#x3D;&#x3D;依旧是保护权限&#x3D;&#x3D;</p><p>​                   父类中的私有权限成员 子类访问不到</p></li><li><p>保护继承：父类中的公共权限成员到子类中&#x3D;&#x3D;变为保护权限&#x3D;&#x3D;</p><p>​                   父类中的保护权限成员到子类中&#x3D;&#x3D;变为保护权限&#x3D;&#x3D;</p><p>​                   父类中的私有权限成员 子类访问不到</p></li><li><p>私有继承：父类中的公共权限成员到子类中&#x3D;&#x3D;变为私有权限&#x3D;&#x3D;</p><p>​                   父类中的保护权限成员到子类中&#x3D;&#x3D;变为私有权限&#x3D;&#x3D;</p><p>​                   父类中的私有权限成员 子类访问不到</p></li></ul></li><li><p>继承中的对象模型：可利用VS中的开发人员命令提示符查看对象模型</p></li><li><p>继承中构造和析构的顺序：&#x3D;&#x3D;父类构造-&gt;子类构造-&gt;父类析构-&gt;子类析构&#x3D;&#x3D;</p></li><li><p>继承中同名处理方式： </p><ul><li><p>非静态成员变量和函数：如果子类成员和父类成员出现同名，编译器会默认隐藏父类中的同名成员                                            子类成员可以直接调用；父类成员需要加上域解析符<code>名称空间：：</code></p></li><li><p>静态成员变量和函数：如果子类成员和父类成员出现同名，编译器会默认隐藏父类中的同名成员</p><p>1.通过对象访问：子类成员可以直接调用；父类成员需要加上域解析符<code>名称空间：：</code></p><p>2.通过类名访问：<code>子类：：静态成员</code>；<code>子类：：父类：：静态成员</code>或者<code>父类：：静态成员</code>访问同名静态成员</p></li></ul></li><li><p>多继承语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> 子类 ：继承方式 父类<span class="hljs-number">1</span>， 继承方式 父类<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>如果多继承成员出现同名，需要使用域解析符：：</p></li><li><p>菱形继承：两个子类继承于一个父类，这两个子类又作为父类继承给一个子类</p><p>​                   菱形继承很可能会导致数据重复和二义性，因此引入虚继承</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived1</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base &#123;&#125;; <span class="hljs-comment">//继承前加上virtual，变为虚继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived2</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base &#123;&#125;; <span class="hljs-comment">//此时公共的父类称为虚基类 </span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MostDerived</span> : <span class="hljs-keyword">public</span> Derived1, <span class="hljs-keyword">public</span> Derived2 &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">foo</span>();  <span class="hljs-comment">// 这是合法的，因为使用了虚继承</span><br>    &#125;<br>&#125;;<br><span class="hljs-comment">//虚继承的本质是继承一个指针,指针的偏移量取决于该子类和基类的距离，因此数据只有一份</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="9-多态"><a href="#9-多态" class="headerlink" title="9.多态"></a>9.多态</h3><ul><li><p>多态分类：</p><table><thead><tr><th align="center">分类</th><th align="center">应用</th><th align="center">区别</th></tr></thead><tbody><tr><td align="center">静态多态</td><td align="center">函数重载 运算符重载 函数名复用</td><td align="center">函数地址早绑定（编译时绑定）</td></tr><tr><td align="center">动态多态</td><td align="center">派生类和虚函数实现运行时多态</td><td align="center">函数地址晚绑定（运行时绑定）</td></tr></tbody></table></li><li><p>虚函数定义：<code>virtual 返回类型 函数名（）</code></p></li><li><p>虚函数表：一个包含了该类所有虚函数地址（虚函数的函数指针）的数组</p></li><li><p>动态多态满足条件：1.有继承关系</p><p>​                                   2.子类重写父类虚函数</p></li><li><p>动态多态的使用：父类的指针或者引用，执行子类对象</p></li><li><p>多态实现的关键：父类的指针或者引用指向子类对象</p></li><li><pre><code class="c++">class Animal  //基类&#123;public:    virtual void speak() //定义虚函数 此时类的内部会有一个叫做vfptr（虚函数表指针）的指针    &#123; //vfptr指针会存储虚函数表的地址，指向该类虚函数表                         //然后虚函数表会找到相应的虚函数，并调用它        cout&lt;&lt;&quot;动物在说话&quot;&lt;&lt;endl;    &#125;&#125;;class Cat : public Animal  //派生类&#123;public:    virtual void speak()  //派生类重写基类，会覆盖基类内容    &#123;        cout&lt;&lt;&quot;小猫在说话&quot;&lt;&lt;endl;      &#125;&#125;;void doSpeak(Animal &amp;animal) //Animal &amp;animal = cat 父类引用（指针）指向子类&#123;                            //等号左边为编译类型 等号右边为运行类型    animal.speak();    &#125;void test01()&#123;    Cat cat;    doSpeak(cat);&#125;//等号左边编译类型，等号右边运行类型，早绑定看编译类型，晚绑定看运行类型<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> 纯虚函数<br><br><span class="hljs-bullet">  -</span> 父类中的虚函数实现毫无意义，主要是调用子类重写的内容，因此需要纯虚函数<br><span class="hljs-bullet">  -</span> 实现：<span class="hljs-code">`virtual 返回值类型 函数名（参数列表）&#123;&#125; = 0 ；`</span><br><span class="hljs-bullet">  -</span> 当一个类中有了纯虚函数，那么这个类为抽象类<br><span class="hljs-bullet">  -</span> 抽象类不可实例化，子函数中必须重写纯虚函数，否则也是抽象类<br><br><span class="hljs-bullet">-</span> 纯虚构和纯虚析构<br><br><span class="hljs-bullet">  -</span> 多态使用时，如果子类有属性开辟到堆区，那么父类指针在释放时无法释放掉子类的在堆区的属性，出现内存泄漏<br><span class="hljs-bullet">  -</span> 实现：<span class="hljs-code">`virtual ~类名（）&#123;&#125; = 0；`</span><br><span class="hljs-bullet">  -</span> 纯虚析构函数必须有实现，需在类外实现<span class="hljs-code">`类名：：~类名（）&#123;&#125;；`</span><br><span class="hljs-bullet">  -</span> 含有纯虚析构函数的类也属于抽象类<br><br><span class="hljs-section">##  六、泛型编程和STL</span><br><br><span class="hljs-section">### 1、模板</span><br><br><span class="hljs-bullet">-</span> C++泛型编程技术通过模板实现<br><br><span class="hljs-bullet">-</span> 模板不可直接使用，模板只是一个框架<br><br><span class="hljs-bullet">-</span> 模板分类：<br><br><span class="hljs-bullet">  -</span> 函数模板<br><br><span class="hljs-bullet">    -</span> 作用：建立一个通用函数，参数用一个虚拟类型来代替<br><br><span class="hljs-bullet">    -</span> 语法：<br><br><span class="hljs-bullet">    -</span> <span class="hljs-code">```c++</span><br><span class="hljs-code">      template &lt;typename T&gt;</span><br><span class="hljs-code">      函数</span><br><span class="hljs-code">      //template 声明创建模板</span><br><span class="hljs-code">      //typename 表明之后是一种类数据类型</span><br><span class="hljs-code">      //T 通用的数据类型</span><br></code></pre></td></tr></table></figure>  - 使用方式：1.自动类型推导：正常调用函数 编译器自身推断具体数据类型    ​                   2.显示类型推导：通过`函数名&lt;数据类型1，数据类型2&gt;（参数1，参数2）`来指定数据类型  - 注意事项：1.若只有一个T，则参数必须完全一致；如果要使用不同的参数，需要用多个T    ​   2.模板必须要确定出T的数据类型，即使传入参数毫无意义  - 函数模板调用时，如果使用自动类型推导，不会发生隐式类型转换，如果利用显示指定类型方式，可以发生隐式类型转换  - 1.调用规则如果函数模板和普通函数都可以实现，优先调用普通函数    2.可以通过空模板参数列表来实现调用函数模板 `返回值类型 函数名&lt;&gt;（参数列表）`    3.函数模板也可以进行重载    4.如果函数模板可以产生更好的匹配（比如遇到类型转换），那就优先调用函数模板  - 模板的局限性：数组、结构体、类这样的自定义数据类型，模板无法识别出来    ​                          解决方案1：运算符重载    ​  解决方案2：`template &lt;&gt; 返回值类型 函数名（自定义数据类型参数列表）&#123;根据自定义数据类型，自行实现功能&#125;`- 类模板  - 语法实现：  - ```cpp    template &lt;typename T&gt;    类    //template 声明创建模板    //typename 表明之后是一种类数据类型    //T 通用的数据类型    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>- 类模板和函数模板的区别：<span class="hljs-number">1.</span>类模板没有自动类型推导的使用方式<br><br>  ​      <span class="hljs-number">2.</span>类模板中参数列表可以指定默认数据类型（如果没有在显示类型推导中提供模板参数，参数T就会使用默认值）<br><br>- 类模板中的成员函数只有在调用的时候才可以创建<br><br>- 类模板实例化对象做函数参数：<br><br>  <span class="hljs-number">1.</span>直接使用值传递<br><br>  ```c++<br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;&#125;;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(MyClass&lt;<span class="hljs-type">int</span>&gt; &amp;obj)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>    2.使用值模板    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(MyClass&lt;T&gt; &amp;obj)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>    3.使用类模板    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">U</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(U obj)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>  - 类模板与继承：    1.当父类是一个类模板时，子类在声明的时候，要具体指定出父类的T数据类型,如果不指定,编译器就无法分配内存    2.如果想要灵活地指定父类中的类型,子类也需要变成类模板    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//父类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    T value;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base&lt;T&gt; &#123;&#125;;<br><span class="hljs-comment">//子类也成为模板类之后,实例化子类时,T就可以变为任何我们想要的类型,而不是像1那样具体指定</span><br></code></pre></td></tr></table></figure>  - 类模板成员函数类外实现:    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    T data;<br>    <span class="hljs-built_in">MyClass</span>(T param);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T param)</span></span>;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 构造函数的外部实现</span><br>MyClass&lt;T&gt;::<span class="hljs-built_in">MyClass</span>(T param) : <span class="hljs-built_in">data</span>(param) &#123;&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 普通成员函数的外部实现</span><br><span class="hljs-type">void</span> MyClass&lt;T&gt;::<span class="hljs-built_in">func</span>(T param) &#123;&#125;<br></code></pre></td></tr></table></figure>  - 类模板分文件编写:    解决方案1.直接包含.cpp文件,这样编译器会先看.h再看.cpp文件    2.将.h和.cpp文件中的内容写到一起,后缀改为.hpp  - 类模板配合友元函数    1.类内实现    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T data;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(T param) : <span class="hljs-built_in">data</span>(param) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">friendFunc</span><span class="hljs-params">(MyClass&lt;T&gt; obj)</span> </span>&#123;<br>        std::cout &lt;&lt; obj.data &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>    2.类外实现    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//在友元函数之前声明这个类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">friendFunc</span><span class="hljs-params">(MyClass&lt;T&gt; obj)</span> </span>&#123;<br>    std::cout &lt;&lt; obj.data &lt;&lt; std::endl;<br>&#125;<span class="hljs-comment">//如果没有在类定义之前声明这个函数，编译器就会把它当作一个新的、非模板的函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T data;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(T param) : <span class="hljs-built_in">data</span>(param) &#123;&#125;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> friendFunc&lt;&gt;(MyClass&lt;T&gt; obj); <br>    <span class="hljs-comment">//注意添加空模板参数列表,表示该函数是一个模板函数,与类外定义相同</span><br>&#125;;<br></code></pre></td></tr></table></figure></code></pre></li></ul><h3 id="2、STL"><a href="#2、STL" class="headerlink" title="2、STL"></a>2、STL</h3><ul><li><p>STL六大组件：容器、算法、迭代器、仿函数、适配器、空间置配器</p></li><li><p>容器 </p><ul><li>序列式容器：强调值的排序，每个元素都有固定的位置</li><li>关联式容器：二叉树结构，各个元素之间没有严格物理上的顺序关系</li></ul></li><li><p>算法</p><ul><li>质变算法：运算过程中会更改区间元素的内容</li><li>非质变算法：预算过程中不会更改区间元素的内容</li></ul></li><li><p>迭代器</p><ul><li>提供一种方法，使之能够寻访某个容器所含的各个元素，而又无需暴露该函数内部的表示方式</li><li>每个容器都有自己的迭代器</li><li>种类：<ul><li>输入迭代器：对数据只读访问</li><li>输出迭代器：对数据只写访问</li><li>前向迭代器：读写操作，并能向前推进迭代器</li><li>双向迭代器：读写操作，并能向前和向后操作</li><li>随机访问迭代器：读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</li></ul></li></ul></li><li><p>string容器</p><ul><li><p>string构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">string</span>();                   <span class="hljs-comment">//创建一个空字符串               </span><br><span class="hljs-built_in">string</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s);      <span class="hljs-comment">//使用C语言风格字符串s初始化一个C++风格字符串</span><br><span class="hljs-built_in">string</span>(<span class="hljs-type">const</span> string&amp; str);  <span class="hljs-comment">//使用一个string对象初始化另外一个string函数</span><br><span class="hljs-built_in">string</span>(<span class="hljs-type">int</span> n,<span class="hljs-type">char</span> c);       <span class="hljs-comment">//使用n个字符c初始化一个字符串</span><br></code></pre></td></tr></table></figure></li><li><p>string字符串赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">string&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*s)    <span class="hljs-comment">//把一个C语言风格字符串 赋值给当前的字符串</span><br>string&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> string &amp;s) <span class="hljs-comment">//把C++风格字符串s赋给当前字符串</span><br>string&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">char</span> c)          <span class="hljs-comment">//把一个字符赋值给当前字符串</span><br>string&amp; <span class="hljs-built_in">assign</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*s)       <span class="hljs-comment">//把C语言风格字符串s赋值给当前字符串</span><br>string&amp; <span class="hljs-built_in">assign</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*s,<span class="hljs-type">int</span> n) <span class="hljs-comment">//把C语言风格字符串s的前n个字符赋给当前的字符串</span><br>string&amp; <span class="hljs-built_in">assign</span>(<span class="hljs-type">const</span> string &amp;s)    <span class="hljs-comment">//把C++风格字符串s赋给当前字符串</span><br>string&amp; <span class="hljs-built_in">assign</span>(<span class="hljs-type">int</span> n,<span class="hljs-type">char</span> C)       <span class="hljs-comment">//用n个字符c赋给当前字符串</span><br></code></pre></td></tr></table></figure></li><li><p>string字符串拼接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">string&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)   <span class="hljs-comment">//把C语言风格字符串放到字符串末尾</span><br>string&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> <span class="hljs-type">char</span> c)   <span class="hljs-comment">//把单个字符放到字符串末尾</span><br>string&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> string&amp; str)   <span class="hljs-comment">//把C++风格字符串放到字符串末尾</span><br>string&amp; <span class="hljs-built_in">append</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)                  <span class="hljs-comment">//把C语言风格字符串s连接到字符串末尾</span><br>string&amp; <span class="hljs-built_in">append</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*s,<span class="hljs-type">int</span> n)             <span class="hljs-comment">//把C语言风格字符串s的前n个字符连接到字符串末尾</span><br>string&amp; <span class="hljs-built_in">append</span>(<span class="hljs-type">const</span> string &amp;s)   <span class="hljs-comment">//把C++风格字符串s连接到字符串末尾</span><br>string&amp; <span class="hljs-built_in">append</span>(<span class="hljs-type">const</span> string &amp;s,<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> n)  <span class="hljs-comment">//把C++风格字符串s从第pos位起的n个数连接到字符串末尾</span><br></code></pre></td></tr></table></figure></li><li><p>string字符串查找和替换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str，<span class="hljs-type">int</span> pos=<span class="hljs-number">0</span>)</span><span class="hljs-type">const</span>         </span><br><span class="hljs-function"><span class="hljs-comment">//从字符串pos位开始查找，C++风格子串str第一次出现位置</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s,<span class="hljs-type">int</span> pos=<span class="hljs-number">0</span>)</span><span class="hljs-type">const</span>            </span><br><span class="hljs-function"><span class="hljs-comment">//从字符串pos位开始查找，C语言风格子串s第一次出现位置</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s,<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> n)</span><span class="hljs-type">const</span>  </span><br><span class="hljs-function"><span class="hljs-comment">//从字符串pos位开始查找，C语言风格子串s的前n个字符出现位置</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> c,<span class="hljs-type">int</span> pos=<span class="hljs-number">0</span>)</span><span class="hljs-type">const</span>  </span><br><span class="hljs-function"><span class="hljs-comment">//查找单个字符第一次出现位置</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rfind</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str，<span class="hljs-type">int</span> npos=<span class="hljs-number">0</span>)</span><span class="hljs-type">const</span> </span><br><span class="hljs-function"><span class="hljs-comment">//从字符串pos位开始查找，C++风格子串str最后一次出现位置</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rfind</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s,<span class="hljs-type">int</span> pos=<span class="hljs-number">0</span>)</span><span class="hljs-type">const</span>  </span><br><span class="hljs-function"><span class="hljs-comment">//从字符串pos位开始查找，C语言风格子串s最后一次出现位置</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rfind</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s,<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> n)</span><span class="hljs-type">const</span>  </span><br><span class="hljs-function"><span class="hljs-comment">//从字符串pos位开始查找，C语言风格子串s的前n个字符最后一次出现位置</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rfind</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> c,<span class="hljs-type">int</span> pos=<span class="hljs-number">0</span>)</span><span class="hljs-type">const</span>    </span><br><span class="hljs-function"><span class="hljs-comment">//查找单个字符最后一次出现位置</span></span><br><span class="hljs-function">string&amp; <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> n,<span class="hljs-type">const</span> string&amp; str)</span>  </span><br><span class="hljs-function"><span class="hljs-comment">//替换从字符串pos位开始n个字符为C++风格字符串str</span></span><br><span class="hljs-function">string&amp; <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> n,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span>   </span><br><span class="hljs-function"><span class="hljs-comment">//替换从字符串pos位开始n个字符为C语言风格字符串s</span></span><br></code></pre></td></tr></table></figure></li><li><p>string字符串比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">//C++风格字符串比较</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span> <span class="hljs-type">const</span></span>;   <span class="hljs-comment">//C语言风格字符串比较</span><br></code></pre></td></tr></table></figure></li><li><p>string字符存取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> n);   <span class="hljs-comment">//用[]取字符</span><br><span class="hljs-function"><span class="hljs-type">char</span>&amp; <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>;    <span class="hljs-comment">//用at取字符</span><br></code></pre></td></tr></table></figure></li><li><p>字符串插入和删除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string&amp; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> pos,<span class="hljs-type">const</span> <span class="hljs-type">char</span>*s)</span></span>;       <span class="hljs-comment">//C语言风格插入 </span><br><span class="hljs-function">string&amp; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> pos,<span class="hljs-type">const</span> string&amp; str)</span></span>;  <span class="hljs-comment">//C++风格插入</span><br><span class="hljs-function">string&amp; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> n,<span class="hljs-type">char</span> c)</span></span>;<span class="hljs-comment">//在指定位置插入n个字符c</span><br><span class="hljs-function">string&amp; <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> n=npos)</span></span>;<span class="hljs-comment">//删除从pos开始的n个字符</span><br></code></pre></td></tr></table></figure></li><li><p>string字串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">substr</span><span class="hljs-params">(<span class="hljs-type">int</span> pos=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> n=npos)</span> <span class="hljs-type">const</span></span>;  <span class="hljs-comment">//从第pos位截取npos个字符</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>vector容器</p><ul><li><p>本质：单端数组 空间连续</p></li><li><p>vector容器支持随机访问</p></li><li><p>动态扩展：在原有基础上开辟一块更大的空间，再将原数组中的数据拷贝进新数组，最后删除原数组 </p></li><li><p>vector的迭代器是可以任意拓展的迭代器</p></li><li><p>vector构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;T&gt; v; <span class="hljs-comment">//采用模板实现类实现，默认构造函数</span><br><span class="hljs-built_in">vector</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());   <span class="hljs-comment">//将v【begin()，end()】区间中的元素拷贝给本身</span><br><span class="hljs-built_in">vector</span>(n,elem); <span class="hljs-comment">//构造函数将n个elem拷贝给本身</span><br><span class="hljs-built_in">vector</span>(<span class="hljs-type">const</span> vector &amp;vec);   <span class="hljs-comment">//拷贝构造函数</span><br></code></pre></td></tr></table></figure></li><li><p>vector赋值操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector <span class="hljs-keyword">operator</span>=&#123;<span class="hljs-type">const</span> vector &amp;vec&#125;; <span class="hljs-comment">//重载等号运算符，实现数组直接赋值</span><br><span class="hljs-built_in">assign</span>(beg,end); <span class="hljs-comment">//将【beg,end】区间中的数据拷贝复制给本身</span><br><span class="hljs-built_in">assign</span>(n,elem); <span class="hljs-comment">//将n个elem拷贝复制给本身</span><br></code></pre></td></tr></table></figure></li><li><p>vector容器的容量和大小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">empty</span>();<span class="hljs-comment">//判断容器是否为空</span><br><span class="hljs-built_in">capacity</span>();    <span class="hljs-comment">//容器的容量</span><br><span class="hljs-built_in">size</span>();<span class="hljs-comment">//返回容器中的元素个数</span><br><span class="hljs-built_in">resize</span>(<span class="hljs-type">int</span> num);<span class="hljs-comment">//重新指定容器长度为num，若容器扩容，则以默认值0填充新位置；</span><br><span class="hljs-comment">//入股容器变短，则末尾超出容器长度的元素被删除</span><br><span class="hljs-built_in">resize</span>(<span class="hljs-type">int</span> num,elem);   <span class="hljs-comment">//重新指定容器的长度为num，若容器扩容，则以elem填充新位置；</span><br><span class="hljs-comment">//若容器缩容，则末尾超出容量长度的元素被删除</span><br></code></pre></td></tr></table></figure></li><li><p>vector容器插入和删除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">push_back</span>(ele);<span class="hljs-comment">//尾部插入元素ele</span><br><span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//删除最后一个元素</span><br><span class="hljs-built_in">insert</span>(const_iterator pos,ele);<span class="hljs-comment">//迭代器指向位置pos插入元素ele</span><br><span class="hljs-built_in">insert</span>(const_iterator pos,<span class="hljs-type">int</span> count,ele);<span class="hljs-comment">//迭代器指向位置pos插入count个元素ele</span><br><span class="hljs-built_in">erase</span>(const_iterator pos);<span class="hljs-comment">//删除迭代器指向元素</span><br><span class="hljs-built_in">erase</span>(const_iterator start,const_iterator end); <span class="hljs-comment">//删除迭代器从start到end之间的元素</span><br><span class="hljs-built_in">clear</span>();<span class="hljs-comment">//删除容器中的所有元素</span><br></code></pre></td></tr></table></figure></li><li><p>vector容器数据存取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">at</span>(<span class="hljs-type">int</span> idx);  <span class="hljs-comment">//返回索引idx所指的数据</span><br><span class="hljs-keyword">operator</span>[];   <span class="hljs-comment">//返回索引idx所指的数据</span><br><span class="hljs-built_in">front</span>();      <span class="hljs-comment">//返回容器中第一个数据元素</span><br><span class="hljs-built_in">end</span>();  <span class="hljs-comment">//返回容器中最后一个数据元素</span><br></code></pre></td></tr></table></figure></li><li><p>vector容器元素互换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">swap</span>(vec);  <span class="hljs-comment">//将vec与本身元素互换</span><br></code></pre></td></tr></table></figure></li><li><p>vector缩容机制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; v; <br><span class="hljs-comment">//v是一个大容量的vector，但实际使用的元素只有一小部分</span><br>resize（<span class="hljs-type">int</span> num）;<br><span class="hljs-comment">//重新设置vector容器的大小</span><br>std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()).<span class="hljs-built_in">swap</span>(v);  <br><span class="hljs-comment">// 创建一个新的匿名vector容器，此时，新的小容量vector替换老的大容量vector</span><br></code></pre></td></tr></table></figure></li><li><p>vector容器预留空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">reserve（<span class="hljs-type">int</span> len）;  <span class="hljs-comment">//容器预留len个容器长度，预留位置不初始化，元素不可访问</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>deque数组</p><ul><li><p>本质：双端数组 空间不连续</p></li><li><p>内部工作原理：内部中控器维护每段缓冲区中的内容，缓冲区中存放真实数据，中控器存储每段缓冲区的地址，使得使用时像一片连续的空间</p></li><li><p>deque容器支持随机访问，但速度慢于vector</p></li><li><p>deque构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">deque&lt;T&gt;deqT; <span class="hljs-comment">//默认构造函数</span><br><span class="hljs-built_in">deque</span>(beg,end); <span class="hljs-comment">//构造函数将beg，end区间中的元素拷贝给本值</span><br><span class="hljs-built_in">deque</span>(n,elem); <span class="hljs-comment">//构造函数将n个elem拷贝给本身</span><br><span class="hljs-built_in">deque</span>(<span class="hljs-type">const</span> deque &amp;deq); <span class="hljs-comment">//拷贝构造函数</span><br></code></pre></td></tr></table></figure></li><li><p>deque赋值操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">deque&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> deque &amp;deq);  <span class="hljs-comment">//重载等号运算符</span><br><span class="hljs-built_in">assign</span>(beg，end);<span class="hljs-comment">//将【beg,end】区间中的数据拷贝复制给本身</span><br><span class="hljs-built_in">assign</span>(n,elem) <span class="hljs-comment">//将n个elem拷贝复制给本身</span><br></code></pre></td></tr></table></figure></li><li><p>deque大小操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">empty</span>();<span class="hljs-comment">//判断容器是否为空</span><br><span class="hljs-built_in">size</span>();<span class="hljs-comment">//返回容器中的元素个数</span><br><span class="hljs-built_in">resize</span>(<span class="hljs-type">int</span> num);<span class="hljs-comment">//重新指定容器长度为num，若容器扩容，则以默认值0填充新位置；若容器变短，则末尾超出容器长度的元素被删除</span><br><span class="hljs-built_in">resize</span>(<span class="hljs-type">int</span> num,elem);   <span class="hljs-comment">//重新指定容器的长度为num，若容器扩容，则以elem填充新位置；若容器变短，则末尾超出容量长度的元素被删除</span><br></code></pre></td></tr></table></figure></li><li><p>deque插入和删除操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//两端插入操作：</span><br><span class="hljs-built_in">push_back</span>(elem);   <span class="hljs-comment">//在容器尾部添加一个数据</span><br><span class="hljs-built_in">push_front</span>(elem);  <span class="hljs-comment">//在容器头部添加一个数据</span><br><span class="hljs-built_in">pop_back</span>();   <span class="hljs-comment">//删除容器最后一个数据</span><br><span class="hljs-built_in">pop_front</span>();   <span class="hljs-comment">//删除容器第一个数据</span><br><span class="hljs-comment">//指定位置操作：</span><br><span class="hljs-built_in">insert</span>(pos,elem);     <span class="hljs-comment">//在pos位插入一个elem元素的拷贝，返回新数据位置</span><br><span class="hljs-built_in">insert</span>(pos,n,elem);   <span class="hljs-comment">//在pos位置插入n个elem数据，无返回值</span><br><span class="hljs-built_in">insert</span>(pos,beg,end);  <span class="hljs-comment">//在pos位置插入beg，end区间内的数据，无返回值</span><br><span class="hljs-built_in">clear</span>();  <span class="hljs-comment">//清空容器所有数据</span><br><span class="hljs-built_in">erase</span>(beg,end);       <span class="hljs-comment">//删除从beg到end的所有数据，返回下一个数据的位置</span><br><span class="hljs-built_in">erase</span>(pos);  <span class="hljs-comment">//删除pos位置的数据，返回下一个数据的位置</span><br></code></pre></td></tr></table></figure></li><li><p>deque容器数据存取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">at</span>(<span class="hljs-type">int</span> idx);<span class="hljs-comment">//返回索引idx所指向的数据</span><br><span class="hljs-keyword">operator</span>[];<span class="hljs-comment">//返回索引idx所指的数据</span><br><span class="hljs-built_in">front</span>();<span class="hljs-comment">//返回容器中的第一个数据元素</span><br><span class="hljs-built_in">back</span>();<span class="hljs-comment">//返回容器中的最后一个数据元素</span><br></code></pre></td></tr></table></figure></li><li><p>deque容器排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(beg,end);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>stack容器</p><ul><li><p>特点：先进后出</p></li><li><p>只有栈顶元素可以被使用，因此不具备遍历的行为</p></li><li><p>stack容器构造：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;T&gt; stk;<span class="hljs-comment">//构造函数</span><br><span class="hljs-built_in">stack</span>(<span class="hljs-type">const</span> stack &amp;stk);<span class="hljs-comment">//默认构造函数</span><br></code></pre></td></tr></table></figure></li><li><p>stack容器赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> stack &amp;stk);  <br></code></pre></td></tr></table></figure></li><li><p>stack容器数据存取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">push</span>(elem);<span class="hljs-comment">//向栈顶添加元素</span><br><span class="hljs-built_in">pop</span>();<span class="hljs-comment">//从栈顶移除一个元素</span><br><span class="hljs-built_in">top</span>();<span class="hljs-comment">//返回栈顶元素</span><br></code></pre></td></tr></table></figure></li><li><p>stack容器大小操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">empty</span>();<span class="hljs-comment">//判断栈是否为空</span><br><span class="hljs-built_in">size</span>();<span class="hljs-comment">//返回栈的大小</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>queue容器</p><ul><li><p>特点：先进先出</p></li><li><p>只有队头和队尾才可以被外界使用到，因此队列不允许遍历行为</p></li><li><p>queue容器构造：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;T&gt; que;<span class="hljs-comment">//构造函数</span><br><span class="hljs-built_in">queue</span>(<span class="hljs-type">const</span> queue &amp;que);<span class="hljs-comment">//默认构造函数</span><br></code></pre></td></tr></table></figure></li><li><p>queue容器赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&amp; <span class="hljs-keyword">operator</span>=（<span class="hljs-type">const</span> queue &amp;que）  <br></code></pre></td></tr></table></figure></li><li><p>queue数据存取：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">push</span>(elem);<span class="hljs-comment">//往队尾添加元素</span><br><span class="hljs-built_in">pop</span>();<span class="hljs-comment">//从队头移除第一个元素</span><br><span class="hljs-built_in">back</span>();<span class="hljs-comment">//返回最后一个元素</span><br><span class="hljs-built_in">front</span>();<span class="hljs-comment">//返回第一个元素</span><br></code></pre></td></tr></table></figure></li><li><p>queue容器大小操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">empty</span>();<span class="hljs-comment">//判断队列是否为空</span><br><span class="hljs-built_in">size</span>();<span class="hljs-comment">//返回队列的大小</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>list容器</p><ul><li><p>本质：双向循环链表</p></li><li><p>特点：非连续存取，使用结点和指针存储数据，可对任意位置进行插入和删除，但是遍历速度慢</p></li><li><p>list容器构造:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">list&lt;T&gt; lst;<span class="hljs-comment">//构造函数</span><br><span class="hljs-built_in">list</span>(beg,end);<span class="hljs-comment">//将beg，end区间内的元素拷贝给本身</span><br><span class="hljs-built_in">list</span>(n,elem);<span class="hljs-comment">//将n个elem拷贝给本身</span><br><span class="hljs-built_in">list</span>(<span class="hljs-type">const</span> list &amp;lst);<span class="hljs-comment">//拷贝构造函数</span><br></code></pre></td></tr></table></figure></li><li><p>list赋值和交换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">list <span class="hljs-keyword">operator</span>=&#123;<span class="hljs-type">const</span> list &amp;lst&#125;;     <span class="hljs-comment">//重载等号运算符，实现链表直接赋值</span><br><span class="hljs-built_in">assign</span>(beg,end); <span class="hljs-comment">//将【beg,end】区间中的数据拷贝复制给本身</span><br><span class="hljs-built_in">assign</span>(n,elem); <span class="hljs-comment">//将n个elem拷贝复制给本身</span><br><span class="hljs-built_in">swap</span>(lst); <span class="hljs-comment">//将lst与自身互换</span><br></code></pre></td></tr></table></figure></li><li><p>list大小操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">empty</span>();<span class="hljs-comment">//判断容器是否为空</span><br><span class="hljs-built_in">size</span>();<span class="hljs-comment">//返回容器中的元素个数</span><br><span class="hljs-built_in">resize</span>(<span class="hljs-type">int</span> num);<span class="hljs-comment">//重新指定容器长度为num，若容器扩容，则以默认值0填充新位置；</span><br>                        <span class="hljs-comment">//入股容器变短，则末尾超出容器长度的元素被删除</span><br><span class="hljs-built_in">resize</span>(<span class="hljs-type">int</span> num,elem);   <span class="hljs-comment">//重新指定容器的长度为num，若容器扩容，则以elem填充新位置；</span><br><span class="hljs-comment">//若容器缩容，则末尾超出容量长度的元素被删除</span><br></code></pre></td></tr></table></figure></li><li><p>list插入和删除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">push_back</span>(elem);<span class="hljs-comment">//在容器尾部插入一个元素</span><br><span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//删除容器最后一个元素</span><br><span class="hljs-built_in">push_front</span>(elem);<span class="hljs-comment">//在容器头部插入一个元素</span><br><span class="hljs-built_in">pop_front</span>();<span class="hljs-comment">//删除容器第一个元素</span><br><span class="hljs-built_in">insert</span>(pos,elem);<span class="hljs-comment">//在pos位置插elem元素，返回新数据的位置</span><br><span class="hljs-built_in">insert</span>(pos,n,elem);<span class="hljs-comment">//在pos位置插n个elem元素</span><br><span class="hljs-built_in">insert</span>(pos,beg,end);<span class="hljs-comment">//在pos位置插入beg，end区间内的数据，无返回值</span><br><span class="hljs-built_in">clear</span>();<span class="hljs-comment">//移除容器所有数据</span><br><span class="hljs-built_in">erase</span>(beg,end);<span class="hljs-comment">//删除beg，end区间内的数据，返回下一个数据的位置</span><br><span class="hljs-built_in">erase</span>(pos);<span class="hljs-comment">//删除pos位置的数据，返回下一个数据的位置</span><br><span class="hljs-built_in">remove</span>(elem);<span class="hljs-comment">//删除容器中所有与elem值匹配的元素</span><br></code></pre></td></tr></table></figure></li><li><p>list数据存取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">front</span>();<span class="hljs-comment">//返回第一个元素</span><br><span class="hljs-built_in">back</span>();<span class="hljs-comment">//返回最后一个元素</span><br></code></pre></td></tr></table></figure></li><li><p>list反转和排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">reverse</span>();<span class="hljs-comment">//反转链表</span><br><span class="hljs-built_in">sort</span>();<span class="hljs-comment">//链表排序 </span><br><span class="hljs-comment">//由于list容器不支持随机访问，容器内部会提供对应的算法，调用时需调用内部的成员函数</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>set&#x2F;multiset容器</p><ul><li><p>所有元素在插入时都会自动排序</p></li><li><p>本质：二叉树</p></li><li><p>set容器不允许出现重复的元素</p></li><li><p>multiset容器允许出现重复的元素</p></li><li><p>set容器构造和赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//构造</span><br>set&lt;T&gt; st;<span class="hljs-comment">//默认构造函数</span><br><span class="hljs-built_in">set</span>(<span class="hljs-type">const</span> set &amp;st);<span class="hljs-comment">//拷贝构造函数</span><br><span class="hljs-comment">//赋值</span><br>set&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> set&amp; st);<br></code></pre></td></tr></table></figure></li><li><p>set容器大小和互换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">size</span>();<span class="hljs-comment">//返回容器中元素的数目</span><br><span class="hljs-built_in">empty</span>();<span class="hljs-comment">//判断容器是否为空</span><br><span class="hljs-built_in">swap</span>(st);<span class="hljs-comment">//交换两个set容器</span><br></code></pre></td></tr></table></figure></li><li><p>set容器 插入和删除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">insert</span>(elem);<span class="hljs-comment">//为容器插入元素</span><br><span class="hljs-built_in">clear</span>();<span class="hljs-comment">//清除所有元素</span><br><span class="hljs-built_in">erase</span>(pos);<span class="hljs-comment">//删除pos迭代器所指向的元素，返回下一个元素的迭代器</span><br><span class="hljs-built_in">erase</span>(beg,end);<span class="hljs-comment">//删除区间beg，end的所有元素，返回下一个元素的迭代器</span><br><span class="hljs-built_in">erase</span>(elem);<span class="hljs-comment">//删除容器中的值为elem的元素</span><br></code></pre></td></tr></table></figure></li><li><p>set容器查找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">find</span>(key);<span class="hljs-comment">//查找key是否存在，存在，则返回该元素迭代器；若不存在，返回set.end();</span><br><span class="hljs-built_in">count</span>(key);<span class="hljs-comment">//统计key元素个数（对于set而言，统计结果要么是0要么是1）</span><br></code></pre></td></tr></table></figure></li><li><p>pair对组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">pair&lt;type1,type2&gt; <span class="hljs-title">p</span> <span class="hljs-params">(value1,value2)</span></span>;<br>pair&lt;type1,type2&gt; p = <span class="hljs-built_in">make_pair</span>(value1,value2);<br><span class="hljs-comment">//可以利用对组实现函数返回两个数据或者将两个元素放在一起</span><br></code></pre></td></tr></table></figure></li><li><p>set容器排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//set容器自身可自动实现数据从小到大排序，如果想改变排序顺序，就需要使用仿函数</span><br><span class="hljs-comment">//set容器有两个模板参数，第一个参数是键的类型，第二个参数是仿函数，用于确定排序顺序</span><br><span class="hljs-comment">//set容器中，依靠&lt;实现升序排序，每次比较都会输出一个布尔值，用于表明数据的先后关系</span><br><span class="hljs-comment">//有了先后关系，set容器才可以进行下一步的排序操作</span><br><span class="hljs-comment">//仿函数实际上就是重载（）运算符，使set容器的排序顺序依照我们定义的方法来排序</span><br><span class="hljs-comment">//仿函数既可以使用结构体struct也可以使用类class</span><br><span class="hljs-comment">//仿函数需要加上const来表示这是一个常量成员函数，因为通常是一个const对象调用它</span><br><span class="hljs-comment">//自定义数据类型，需要单独提供排序规则</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Compare</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; a, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; b)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a &gt; b;  <span class="hljs-comment">// 降序排序</span><br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::set&lt;<span class="hljs-type">int</span>, Compare&gt; s;<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>);<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : s) &#123;<br>        std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：3 2 1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul></li><li><p>map容器</p><ul><li><p>特点:map容器中所有数据都是pair对组</p><p>pair对组第一个元素是键值，第二个元素是实值</p><p>所有元素按照键值进行排序  </p></li><li><p>本质：二叉树</p></li><li><p>优点：可以根据key值快速找到value值</p></li><li><p>map容器构造与赋值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//构造</span><br>map&lt;T1,T2&gt; mp;<br><span class="hljs-built_in">map</span>(<span class="hljs-type">const</span> map &amp;mp);<br><span class="hljs-comment">//赋值</span><br>map&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> map &amp;mp);<br></code></pre></td></tr></table></figure></li><li><p>map容器大小和交换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">empty</span>();<span class="hljs-comment">//判断容器是否为空</span><br><span class="hljs-built_in">size</span>();<span class="hljs-comment">//返回容器中元素的数目</span><br><span class="hljs-built_in">swap</span>(st);<span class="hljs-comment">//交换两个map容器</span><br></code></pre></td></tr></table></figure></li><li><p>map容器插入和删除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">insert</span>();<span class="hljs-comment">//在容器中插入元素</span><br><span class="hljs-built_in">clear</span>();<span class="hljs-comment">//清除所有元素</span><br><span class="hljs-built_in">erase</span>(pos);<span class="hljs-comment">//删除pos迭代所指向的元素，返回下一个元素的迭代器</span><br><span class="hljs-built_in">erase</span>(beg,end);<span class="hljs-comment">//删除区间beg，end内所有的元素，返回下一个元素的迭代器</span><br><span class="hljs-built_in">erase</span>(key);<span class="hljs-comment">//删除容器中值为key的元素</span><br></code></pre></td></tr></table></figure></li><li><p>map容器查找和统计</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">find</span>(key);<span class="hljs-comment">//查找key是否存在，若存在，返回该键的迭代器；若不存在，返回map.end（）</span><br><span class="hljs-built_in">count</span>(key);<span class="hljs-comment">//统计key元素的个数</span><br></code></pre></td></tr></table></figure></li><li><p>map容器排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//map容器自身可自动实现数据从小到大排序，如果想改变排序顺序，就需要使用仿函数</span><br><span class="hljs-comment">//map容器有三个模板参数，前两个参数是键和值的类型，第三个参数是仿函数，用于确定排序顺序</span><br><span class="hljs-comment">//map容器中，依靠&lt;实现升序排序，每次比较都会输出一个布尔值，用于表明数据的先后关系</span><br><span class="hljs-comment">//有了先后关系，map容器才可以进行下一步的排序操作</span><br><span class="hljs-comment">//仿函数实际上就是重载（）运算符，使map容器的排序顺序依照我们定义的方法来排序</span><br><span class="hljs-comment">//仿函数既可以使用结构体struct也可以使用类class</span><br><span class="hljs-comment">//仿函数需要加上const来表示这是一个常量成员函数，因为通常是一个const对象调用它</span><br><span class="hljs-comment">//自定义数据类型，需要单独提供排序规则</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Compare</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; a, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; b)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a &gt; b;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, Compare&gt; m;<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>));<br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>,<span class="hljs-number">20</span>));<br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>,<span class="hljs-number">30</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : m) &#123;<br>        std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3、函数对象"><a href="#3、函数对象" class="headerlink" title="3、函数对象"></a>3、函数对象</h3><ul><li><p>概念：重载函数调用操作符的<strong>类</strong>，其实例化的对象成为函数对象</p></li><li><p>函数对象使用重载的（），行为类似于函数，因此又成为仿函数</p></li><li><p>函数对象的使用： 1.使用函数对象时，类似于函数，可以有参数，可以有返回值</p><p>​2.函数对象可以有自己的状态</p><p>​3.函数对象可以作为参数</p></li><li><p>返回值为bool类型的函数对象称为谓词</p></li><li><p>如果operator（）接受一个参数，叫做一元谓词</p></li><li><p>如果operator（）接受两个参数，叫做二元谓词</p></li><li><p>内建函数对象：（需要#include <functional>）</functional></p><ul><li><p>算数仿函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; T plus&lt;T&gt;;<span class="hljs-comment">//加法仿函数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; T minus&lt;T&gt;;<span class="hljs-comment">//减法仿函数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; T multiplies&lt;T&gt;;<span class="hljs-comment">//乘法仿函数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; T divides&lt;T&gt;;<span class="hljs-comment">//除法仿函数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; T modulus&lt;T&gt;;<span class="hljs-comment">//取模仿函数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; T negate&lt;T&gt;;<span class="hljs-comment">//取反仿函数</span><br></code></pre></td></tr></table></figure></li><li><p>关系仿函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> equal_to&lt;T&gt;;<span class="hljs-comment">//等于</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> not_equal_to&lt;T&gt;;<span class="hljs-comment">//不等于</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> greater&lt;T&gt;;<span class="hljs-comment">//大于</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> greater_equal&lt;T&gt;;<span class="hljs-comment">//大于等于</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> less&lt;T&gt;;<span class="hljs-comment">//小于</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> less_equal&lt;T&gt;;<span class="hljs-comment">//小于等于</span><br></code></pre></td></tr></table></figure></li><li><p>逻辑仿函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> logical_and&lt;T&gt;;<span class="hljs-comment">//逻辑与</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> logical_or&lt;T&gt;;<span class="hljs-comment">//逻辑或</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> logical_not&lt;T&gt;;<span class="hljs-comment">//逻辑非</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="4-常用算法"><a href="#4-常用算法" class="headerlink" title="4.常用算法"></a>4.常用算法</h3><ul><li><p>遍历算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">for_each(iterator beg,iterator end,_func);<span class="hljs-comment">//逐个遍历容器中的元素</span><br><span class="hljs-comment">//起始迭代器 终止迭代器 函数或函数对象</span><br><span class="hljs-built_in">transform</span> (iterator beg1,iterator end,iterator beg2,_func);  <span class="hljs-comment">//搬运容器到另一个容器之中</span><br><span class="hljs-comment">//原容器起始迭代器 原容器种植迭代器 目标容器起始迭代器 函数和仿函数</span><br></code></pre></td></tr></table></figure></li><li><p>查找算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">find</span>(iterator beg,iterator end,value);<br><span class="hljs-comment">//按值查找元素，找不到返回结束迭代器位置，找到返回指定迭代器位置</span><br><span class="hljs-comment">//起始迭代器 终止迭代器 查找值</span><br><span class="hljs-built_in">find_if</span>(iterator beg,iterator end,_Pred);<br><span class="hljs-comment">//按值查找元素，找不到返回结束迭代器位置，找到返回指定迭代器位置</span><br><span class="hljs-comment">//起始迭代器 终止迭代器 函数或谓词</span><br><span class="hljs-built_in">adjacent_find</span>(iterator beg,iterator end);<br><span class="hljs-comment">//查找相邻迭代器，返回相邻元素的第一个元素的迭代器</span><br><span class="hljs-comment">//起始迭代器 终止迭代器</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(iterator beg,iterator end,value)</span></span>;<br><span class="hljs-comment">//查找指定元素，查到返回true否则返回false</span><br><span class="hljs-comment">//在无序序列中不可使用</span><br><span class="hljs-comment">//起始迭代器 中止迭代器 查找值</span><br><span class="hljs-built_in">count</span>(iterator beg,iterator end,value);<br><span class="hljs-comment">//统计元素出现次数</span><br><span class="hljs-comment">//起始迭代器 终止迭代器 统计的元素</span><br><span class="hljs-built_in">count_if</span>(iterator beg,iterator end,_Pred)；<br><span class="hljs-comment">//按条件统计元素出现个数</span><br><span class="hljs-comment">//起始迭代器 终止迭代器 谓词</span><br></code></pre></td></tr></table></figure></li><li><p>排序算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(iterator beg,iterator end,_Pred);<br><span class="hljs-comment">//按值查找元素，找到返回指定位置的迭代器，找不到返回结束位置的迭代器</span><br><span class="hljs-comment">//起始迭代器 终止迭代器 谓词</span><br><span class="hljs-built_in">random_shuffle</span>(iterator beg,iterator end);<br><span class="hljs-comment">//指定范围内的元素随随机调整次序</span><br><span class="hljs-comment">//起始迭代器 终止迭代器</span><br><span class="hljs-built_in">merge</span>(iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest);<br><span class="hljs-comment">//容器元素合并，并存储到一个容器当中</span><br><span class="hljs-comment">//起始迭代器1 终止迭代器1 起始迭代器2 终止迭代器2 目标容器起始迭代器</span><br><span class="hljs-built_in">reverse</span>(iterator beg,iterator end);<br><span class="hljs-comment">//反转范围内的元素</span><br><span class="hljs-comment">//起始迭代器 终止迭代器</span><br></code></pre></td></tr></table></figure></li><li><p>常用拷贝和替换算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">copy</span>(iterator beg,iterator end, iterator dest)<br><span class="hljs-comment">//将容器内指定范围的元素拷贝到另一迭代器</span><br><span class="hljs-comment">//起始迭代器 终止迭代器 目标起始迭代器 </span><br><span class="hljs-built_in">replace</span>(iterator beg,iterator end, oldvalue, newvalue)<br><span class="hljs-comment">//将区间内的旧元素换为新的元素</span><br><span class="hljs-comment">//起始迭代器 终止迭代器 旧的元素 新的元素    </span><br><span class="hljs-built_in">replace_if</span>(iterator beg,iterator end, _Pred, newvalue)    <br><span class="hljs-comment">//将区间内满足条件的元素替换为指定元素</span><br><span class="hljs-comment">//起始迭代器 终止迭代器 谓词 新元素  </span><br><span class="hljs-built_in">swap</span>(container c1,container c2)<br><span class="hljs-comment">//互换容器中的元素</span><br><span class="hljs-comment">//容器类型必须一致</span><br></code></pre></td></tr></table></figure></li><li><p>常用算术生成算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//需要包含头文件 #include&lt;numeric&gt;</span><br><span class="hljs-built_in">accumulate</span>(iterator beg,iterator end, value)<br><span class="hljs-comment">//计算区间内元素总和</span><br><span class="hljs-comment">//起始迭代器 终止迭代器 起始值</span><br><span class="hljs-built_in">fill</span>(iterator beg,iterator end, value)<br><span class="hljs-comment">//向容器中指定区间填充元素</span><br><span class="hljs-comment">//起始迭代器 终止迭代器 填充值</span><br></code></pre></td></tr></table></figure></li><li><p>常用集合算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">set_intersection</span>(iterator beg1, iterator end1, iterator beg2, iteraotr end2,iterator dest)<br><span class="hljs-comment">//取两个容器元素的交集 </span><br><span class="hljs-comment">//容器1起始迭代器 容器1终止迭代器 容器2起始迭代器 容器2中止迭代器 交集的终止迭代器</span><br><span class="hljs-comment">//目标容器需要提前开辟空间 最坏情况为：小容器的size </span><br><span class="hljs-comment">//如果交集元素个数小于最坏情况size，可通过返回的终止迭代器来访问交集全部的元素，避免访问到多余的0</span><br><span class="hljs-built_in">set_union</span>(iterator beg1, iterator end1, iterator beg2, iteraotr end2,iterator dest)<br><span class="hljs-comment">//取两个容器元素的并集</span><br><span class="hljs-comment">//容器1起始迭代器 容器1终止迭代器 容器2起始迭代器 容器2中止迭代器 并集的终止迭代器</span><br><span class="hljs-comment">//目标容器需要提前开辟空间 最坏情况为：两个容器的size之和</span><br><span class="hljs-comment">//如果并集元素个数小于最坏情况size，可通过返回的终止迭代器来访问交集全部的元素，避免访问到多余的0</span><br><span class="hljs-built_in">set_difference</span>(iterator beg1, iterator end1, iterator beg2, iteraotr end2,iterator dest)  <br><span class="hljs-comment">//求两个容器的差集</span><br><span class="hljs-comment">//容器1起始迭代器 容器1终止迭代器 容器2起始迭代器 容器2中止迭代器 并集的终止迭代器</span><br><span class="hljs-comment">//目标容器需要提前开辟空间 最坏情况为：大容器的size</span><br><span class="hljs-comment">//如果差集元素个数小于最坏情况size，可通过返回的终止迭代器来访问交集全部的元素，避免访问到多余的0</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2024/09/15/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2024/09/15/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p><p><img src="/2024/09/15/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/5b0b4ddd3ca1279af6c8ac9c61fc73a.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/09/14/hello-world/"/>
    <url>/2024/09/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
